#!/usr/bin/env python

import argparse
import json
import time
from pathlib import Path

from packaging.version import Version
from tabulate import tabulate


def fetch_builds(path):
    if isinstance(path, str):
        path = Path(path)
    store = json.loads(path.read_text()) if path.exists() else {}
    return list(store.keys())


def fetch_latest(builds):
    latest = {}
    py_versions = {}
    for build in builds:
        package, version, py_version, os = build.split('-')
        package = (
            package.replace('numpy', 'NumPy')
            .replace('scipy', 'SciPy')
            .replace('_', '-')
        )
        key = (package, os.capitalize())
        if Version(version) >= latest.get(key, Version('0')):
            if Version(version) > latest.get(key, Version('0')):
                py_versions[key] = []
            py_versions[key] = sorted({py_version} | set(py_versions[key]))
            latest[key] = Version(version)

    return sort_entries(latest), sort_entries(py_versions)


def sort_entries(dct):
    keys = sorted(dct.keys())
    return {k: dct[k] for k in keys}


def parse_python_versions(v):
    min_, max_ = min(v), max(v)
    return f'≥{min_[2]}.{min_[3:5]}, ≤{max_[2]}.{max_[3:5]}'


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Create release notes from template')
    parser.add_argument('template', type=str, help='template file')
    parser.add_argument('-s', '--store', required=True, type=str, help='store file')

    args = parser.parse_args()
    builds = fetch_builds(Path(args.store))
    template = Path(args.template).read_text()

    latest, py_versions = fetch_latest(builds)
    table = [['Package', 'OS', 'Latest version', 'Supported Python versions']]
    for key, latest_ in latest.items():
        table.append([*key, latest_, parse_python_versions(py_versions[key])])

    md_table = tabulate(table[1:], headers=table[0], tablefmt='github')

    notes = template.format(date=time.strftime('%Y-%m-%d'), latest=md_table)
    print(notes)
